---
title: "FlowSOM of IMP RM15"
output: html_document
date: "2025-09-26"
---

## Introduction

This script will create a self-organising map from flow cytometry data generated by Ross McKenzie, comparing TCR-dependent stimulation vs TCR-independent stimulation vs PBS controls. Data from replicate datasets will then be mapped onto the original SOM to determine whether differences in the proportions of cells in each cluster replicate across independent experiments.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(flowCore)
library(FlowSOM)
library(ggplot2)
library(pheatmap)
files <- list.files(pattern="fcs", full.names=FALSE)
ff <- flowCore::read.flowSet(files)

```

## Transform the data

First we concatenate all of the samples.

```{r concatenate}
catff <- as(ff, "flowFrame")
```

## Estimation of the transformation

Now we estimate the transformation on all cells together and apply it. Note that because of the range of the spectral flow data in many experiments, we have changed m to 5.
Used X and Y to specify only the fluorescent markers (no time, scatter or Original)

```{r transform}
colnames(catff)
transformList <- flowCore::estimateLogicle(catff, channels = colnames(catff[,c(1:40)]), m=5
) ## note that we are only transforming channels with fluorescence, not other random things
catff <- flowCore::transform(catff, transformList)
```
## Calculate flowSOM - default clustering

First we will calculate the SOM using the inbuilt iteration to decide the best number of metaclusters. We have to select the channels to use based on where we have relevant antibodies. Once made, we visualise the SOM.
<!-- When you run the second line "channels1" it will print all of the possible channels to run the clustering on along with their indices. Use the "colsToUse" argument to indicate which ones have channels that you care about (not exclusively myeloid or B cell markers, etc). As you can see, the vector in "c(X, Y:Z, ...)" can be indicated by marking each marker individually, separated by commas, or ranges separated by commas. -->

```{r defaultclustering}
channels1 <- catff@parameters@data
channels1

flowSOM.res <- FlowSOM(catff, scale = FALSE, colsToUse = c(1, 5:7, 9:10, 12:13, 16:22, 25:32, 34:37, 39:40), maxMeta=20, seed=1111) # here the colsToUse argument has chosen channels of interest - excluding markers of other cell types or things used for prior gating
FlowSOMmary(flowSOM.res, "FlowSOMmary_iterateMetaa.pdf")

```
## Calculate flowSOM - iterative clustering

Iterate through with 5-15 clusters to find the degree of clustering that captures the heterogeneity of interest in terms of classical markers.
<!-- Change the "colsToUse" argument to the vector of channels used above -->
<!-- Add sample conditions where indicated based on the list of samples in the order they have been read in. -->

```{r iterateclustering}
files ## This will print out the file names. It should be in the same order as in the concatenated flowframe object. Use this list to make the vector indicated below of the order of conditions in the dataset.
for(i in 5:15){
  flowSOM.resiter <- FlowSOM(catff, scale = FALSE, 
                             colsToUse = c(1, 5:7, 9:10, 12:13, 16:22, 25:32, 34:37, 39:40), 
                             nClus=i, seed=1111) # channel selection applied again
  FlowSOMmary(flowSOM.resiter, paste0("FlowSOMmary_", as.character(i), "clust.pdf"))
  
  clust_memb <- GetClusters(flowSOM.resiter)
  clust_memb <- data.frame(sample=exprs(catff)[,ncol(catff)], cluster=clust_memb)
  clust_memb$metacluster <- flowSOM.resiter$metaclustering[clust_memb$cluster]
  tab <- table(clust_memb$sample, clust_memb$metacluster)
  sumtab <- rowSums(tab)
  proptab <- apply(tab, 2, function(x){x/sumtab})

  dflong <- data.frame(proportion=vector('numeric', 0), cluster=vector('character', 0), condition=vector('character', 0))
  for(j in 1:ncol(proptab)){
    dfclust <- data.frame(proportion=proptab[,j],
                          cluster=rep(colnames(proptab)[j], nrow(proptab)),
                          condition=c('FLU-OVA', 'PBS', 'PBS', 'FLU-OVA', 'FLU-OVA', 'FLU-OVA', 'FLU', 'FLU', 'FLU', 'FLU', 'PBS')) ## this is a placeholder right now - it needs to be a vector with the sample conditions listed in the same order as the flow files, the same length as the number of flow files read in.
    dflong <- rbind(dflong, dfclust)
  }
  dflong$condition <- factor(as.character(dflong$condition), levels=c('PBS', 'FLU', 'FLU-OVA')) # reveling again
  dflong$cluster <- factor(as.character(dflong$cluster),
                           levels=as.character(c(1:i)))
  g <- ggplot(dflong, aes(fill=condition, y=proportion, x=cluster)) +
    geom_dotplot(binaxis='y', stackdir='center',
                 position=position_dodge(0.7), dotsize=2, binwidth = 0.005) +
    scale_fill_manual(values=c('grey', 'purple', 'red')) + # colour choice - whatever you'd like - they will be in the same order as the "levels" command above, which is currently "PBS", "FLU", "FLU-OVA"
    theme_classic()
  pdf(file=paste0("proportion_plot_", as.character(i), "_clusters.pdf"), height=7, width=6+0.5*i)
  print(g)
  dev.off()
  
  write.table(dflong, 
              file=paste0('proportions_', as.character(i), '_clusters_final.txt'), 
              sep='\t', quote=FALSE, row.names=FALSE)

  MFIs <- flowSOM.resiter$map$metaclusterMFIs
  colnames(MFIs) <- pData(parameters(catff))$desc
  p <- pheatmap(MFIs[,c(1, 5:7, 9:10, 12:13, 16:22, 25:32, 34:37, 39:40)]) # column choice again
  pdf(paste0("heatmap_", as.character(i), "_clusters.pdf"))
  print(p)
  dev.off()
}

flowSOM.res15 <- FlowSOM(catff, scale = FALSE, 
                           colsToUse = c(1, 5:7, 9:10, 12:13, 16:22, 25:32, 34:37, 39:40), 
                           nClus=15, seed=1111) # column choice again
FlowSOMmary(flowSOM.res15, paste0("FlowSOMmary_7clust_final.pdf"))

```
## Integrating data sets

Now we will map a second dataset onto the same SOM to see if the differences in proportions of cells within each cluster replicate. 

Read in the new data.

```{r readnewdata, eval=FALSE}
## Here we have to redirect the path to a different directory that holds the next set of samples. This directory must be part of both the search for files in the first command and the path to the files in the second command.

files <- list.files(path="IMP RM03/", pattern="fcs", full.names=FALSE)
gg <- flowCore::read.flowSet(paste0("IMP RM03/", files))
```

Concatenate everything to transform it.

```{r concatenatenewdata, eval=FALSE}
catgg <- as(gg, "flowFrame")
```

Estimate the transformation and apply it.

```{r transformnewdata, eval=FALSE}
colnames(catgg)
transformList <- flowCore::estimateLogicle(catgg, channels = colnames(catgg[,c(1:40)]), m=5) # once again we have limited ourselves to the fluorescent channels
catgg <- flowCore::transform(catgg, transformList)

flowSOM.resb <- FlowSOM(catff, scale = FALSE, colsToUse = c(1, 5:7, 9:10, 12:13, 16:22, 25:32, 34:37, 39:40), maxMeta=20, seed=1111)
```

Ensure channel markers are in the same order and then map the new data to the flowSOM grid.

```{r mapnewdata, eval=FALSE}
channels2 <- catgg@parameters@data
all.equal(channels1$desc, channels2$desc)
# not all equal
# must reorder new flowframe

# check names are the same
table(colnames(catgg) %in% channels1$name)
# all are the same, just the order is different

catfg <- catgg[,channels1$name]
channels2 <- catffg@parameters@data
all.equal(channels1$desc, channels2$desc)
# now it's good
## of note, I also ran without reordering, and it was identical. NewData appears to map by channel name already

flowSOM.new <- NewData(flowSOM.res15, catgg, compensate=FALSE, transform=FALSE, scale=FALSE)
FlowSOMmary(flowSOM.new, paste0("FlowSOMmary_15clust_data2mapped.pdf"))

```